// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#ifndef IOTHUB_CLIENT_AMQP_INTERNAL_H
#define IOTHUB_CLIENT_AMQP_INTERNAL_H

#include "proton/message.h"
#include "proton/messenger.h"

#include "strings.h"
#include "doublylinkedlist.h"
#include "crt_abstractions.h"

#ifdef __cplusplus
extern "C"
{
#endif

#define PROTON_MAP_OPERATIONS_KEY "operation"
#define PROTON_MAP_PUT_TOKEN_OPERATION "put-token"
#define PROTON_MAP_TYPE_KEY "type"
#define PROTON_MAP_TOKEN_TYPE "azure-devices.net:sastoken"
#define PROTON_MAP_NAME_KEY "name"
#define PROTON_MAP_STATUS_CODE "status-code"
#define PROTON_MAP_STATUS_DESCRIPTION "status-description"

#define AMQPS_SCHEME "amqps://"

#define EPOCH_TIME_T_VALUE (time_t)0

//
// The following items are in units of seconds
#define CBS_DEFAULT_REQUEST_ACCEPT_TIME (60)
#define CBS_DEFAULT_REPLY_TIME (60)
#define SAS_TOKEN_DEFAULT_LIFETIME (3600)
#define SAS_TOKEN_DEFAULT_REFRESH_LINE (600)
#define EVENT_TIMEOUT_DEFAULT (30)


typedef struct AMQP_TRANSPORT_STATE_TAG
{
    //
    // String generated by the create routine that is passed to the underlying transport; it is the "destination" address of the
    // event operations.
    //
    STRING_HANDLE eventAddress;

    //
    // String generated by the create routine that is passed to the underlying transport; it is the "source" address of messages.
    //
    STRING_HANDLE messageAddress;

    //
    // Obtained from the config structure.  Since this will be passed in url's we need to url encode it.  We keep it in the
    // device state because it is used whenever we need to (re)initialize the proton messenger, and it is also used as the name of the
    // device key in SAS tokens which are periodically generated during this current life of the device.
    STRING_HANDLE urledDeviceId;

    //
    // We need to store the device key as it is needed to periodically generate a new SAS token.
    STRING_HANDLE deviceKey;

    //
    // Built up from the urlDeviceId and a portion of the relative url path, this is used as the "audience" for CBS tokens.  As such
    // we need to keep it around for SAS cbs maintainence.  Also, it used during formation of various other strings.
    STRING_HANDLE devicesPortionPath;

    //
    // This is the url of CBS for the particualar IoT hub.  It is used to periodically send a put-token request to authenticate the device.
    STRING_HANDLE cbsAddress;

    //
    // Needed for device scoped key names.
    STRING_HANDLE zeroLengthString;

    //
    // This is the proton object that controls all aspects of the connection to the cloud.
    //
    pn_messenger_t* messenger;

    //
    // This controls whether we need to reinitialize (or initialize) the lower level transport connection to the cloud service.
    bool messengerInitialized;

    //
    // This is a proton object that is used to build up an event item or to hold a received message.  Since we are only doing
    // one operation at a time, it's helpful to just pre-allocate it.  We have been assured by the proton folk that subsequent to a
    // pn_messenger_put, the contents of a message can be immediately cleared.
    pn_message_t* message;

    //
    // Pointer to a shared list (with the transport independent upper layer) that contains event items to send.
    PDLIST_ENTRY waitingToSend;

    //
    // Holds the work descriptions of currently "in flight" event items.
    DLIST_ENTRY workInProgress;

    //
    // Holds the work descriptions that aren't being used.
    DLIST_ENTRY availableWorkItems;

    //
    // Flag to indicate whether we should pull for messages.
    bool DoWork_PullMessages;

    //
    // Flag to indicate that we've done a put token operation to the CBS and are now awaiting a reply.
    bool waitingForPutTokenReply;
    
    //
    // Holds the expiry (seconds since the epoch) that was last used for the SAS put to the CBS
    size_t lastExpiryUsed;

    //
    // Because of the organization of the receive processing it simply more straight forward to set a global
    // in the state to indicate we've successfully gone through a full request reply cycle for the CBS SAS token
    // renewal.
    bool putTokenWasSuccessful;

    //
    // We will use the expiration value for a SAS that is being sent to the CBS as the message id of actual amqp xfer frame.
    // While processing responses from return subscription to the CBS we look for this message id.
    size_t sendTokenMessageId;

    //
    // This is where messengers go when they just won't stop.
    DLIST_ENTRY messengerCorral;

    //
    // We need to save the client handle for those times we're completing something and don't have that handle.
    IOTHUB_CLIENT_LL_HANDLE savedClientHandle;

    //
    // The proton subscription used to retrieve messages.  Obtained at initialization of the messenger.
    pn_subscription_t* messageSubscription;

    //
    // The proton subscription used to retrieve replys to putting the SAS token to the CBS. Obtained at initialization of the messenger.
    pn_subscription_t* cbsSubscription;

    //
    // The maximum amount of time to wait for CBS request to be accepted by service.  This does
    // NOT mean how long it takes for a round trip.  Just how long it takes for the service to put
    // the request in a terminal state.  Units in seconds.
    size_t cbsRequestAcceptTime;

    //
    // The maximum amount of time to wait for a CBS reply to come in.  Units is in seconds.
    size_t cbsReplyTime;

    //
    // This will hold the amount of time (in seconds) that a SAS Token will have for it's expiration.
    size_t sasTokenLifetime;

    //
    // This will hold how many seconds before the expiration of a SAS token we will try to start renewing
    // it.
    size_t sasRefreshLine;

    //
    // The number of seconds that an event item may be pending before the transport decides that the
    // connection is not working.
    size_t eventTimeout;

	//
	// A string containing the trusted certificates to be passed down to Proton
	char* trustedCertificates;
} AMQP_TRANSPORT_STATE, *PAMQP_TRANSPORT_STATE;

#ifdef __cplusplus
}
#endif

#endif /* IOTHUB_CLIENT_AMQP_INTERNAL_H */
